<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="ExploreZelda is an interactive map for finding hidden treasure, routing speedruns, 100% playthru, etc..." />
    <meta name="keywords" content="zelda, zelda map, totk map, Tears of the Kingdom map, hyrule map, totk guide, speedrun" />
    <meta name="robots" content="index, follow">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:creator" content="@designgears">
    <meta name="twitter:title" content="ExploreZelda: Tears of the Kingdom Interactive Map">
    <meta name="twitter:description" content="ExploreZelda is an interactive map for finding hidden treasure, routing speedruns, 100% playthru, etc...">
    <meta name="twitter:image" content="https://explorezelda.com/assets/img/large.jpg">

    <meta property="og:locale" content="en_US">
    <meta property="og:title" content="ExploreZelda: Tears of the Kingdom Interactive Map" />
    <meta property="og:site_name" content="Explore Zelda">
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://explorezelda.com/" />
    <meta property="og:image" content="https://explorezelda.com/assets/img/og.jpg" />
    <meta property="og:description" content="ExploreZelda is an interactive map for finding hidden treasure, routing speedruns, 100% playthru, etc..." />
    
    <link rel="icon" href="favicon.ico">

    <title>ExploreZelda: Tears of the Kingdom Interactive Map</title>

    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.2.3/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.10.5/font/bootstrap-icons.min.css" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.3/leaflet.css" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet-search/3.0.9/leaflet-search.min.css" />
    <link rel="stylesheet" type="text/css" href="assets/css/leaflet.groupedlayercontrol.min.css" />
    
    <style type="text/css">

        @font-face {
            font-family: 'Hylia Serif Beta';
            src: url('assets/fonts/HyliaSerifBeta-Regular.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'OpenSans';
            src: url('assets/fonts/OpenSans-VariableFont_wdth,wght.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        * {
            font-family: 'OpenSans';
        }

        html, body {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
        }

        canvas {
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0);
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .leaflet-control-layers-group > .leaflet-control-layers-group-label {
            text-decoration: underline;
        }

        .leaflet-control-layers-group > label:not(.leaflet-control-layers-group-label) {
            font-style: italic;
            margin-left: 10px;
        }

        .leaflet-control-layers-expanded {
            min-width: 220px;
        }

        .leaflet-control-zoom-in,
        .leaflet-control-zoom-out,
        .leaflet-control-attribution,
        .leaflet-popup-content-wrapper,
        .leaflet-popup-tip,
        .leaflet-tooltip,
        .leaflet-control {
            background-color: rgb(24, 26, 27) !important;
            color: rgb(200, 195, 188) !important;
            border: 0 !important;
        }

        .leaflet-tooltip-bottom:before {
            border-color: transparent transparent rgb(24, 26, 27) transparent !important;
        }

        .leaflet-control-zoom-in {
            border-bottom: 1px solid rgb(104, 101, 97) !important;
        }

        .leaflet-control-layers-separator {
            border-top: 1px solid rgb(104, 101, 97) !important;
        }

        .leaflet-control-layers-group-label input[type=checkbox] {
            vertical-align: middle;
            float: right;
            margin: 2px 2px 2px 0;
        }

        #map {
            height: 100vh;
            width: 100vw;
            background: #222 url(assets/images/swirl-black.jpg);
        }
        
    </style>

  </head>

  <body>

    <div id="map"></div>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.2.3/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.3/leaflet-src.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-hash/0.2.1/leaflet-hash.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-search/3.0.9/leaflet-search.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script type="text/javascript" src="assets/js/Leaflet.CanvasMarkerCircle.js"></script>
    <script type="text/javascript" src="assets/js/leaflet.groupedlayercontrol.js"></script>

    <script type="text/javascript">

        $.ajaxSetup({ cache: false });
        var completedMarkers = [];

        Storage.prototype.setObj = function(key, obj) {
            return this.setItem(key, JSON.stringify(obj))
        }
        Storage.prototype.getObj = function(key) {
            return JSON.parse(this.getItem(key))
        }

        if (localStorage.getItem("completedMarkers") !== '' && localStorage.getObj("completedMarkers") !== null) {
            completedMarkers = localStorage.getObj("completedMarkers");
        } else {
            localStorage.setObj("completedMarkers", completedMarkers);
        }

        function completeMarker(feature) {
            var index = completedMarkers.indexOf(feature.properties.hash);
            if (index == -1) {
                completedMarkers.push(feature.properties.hash);
                localStorage.setObj("completedMarkers", completedMarkers);
            }
        }

        function removeCompleteMarker(feature) {
            var index = completedMarkers.indexOf(feature.properties.hash);
            if (index > -1) {
                completedMarkers.splice(index, 1);
                localStorage.setObj("completedMarkers", completedMarkers);
            }
        }

        function x(coords) {
            return zeldaMap.unproject([coords[0], coords[1]], 8);
        }

        var tileSize = 256,
            factorx = 1 / (tileSize / 3), // 3 image pixels per game unit
            factory = 1 / (tileSize / 3),
            imageheight = 30000,
            imagewidth = 36000;

        L.CRS.Zelda = L.extend({}, L.CRS.Simple, {
            projection: L.Projection.LonLat,
            transformation: new L.Transformation(factorx, 70.31, -factory, 58.59),
        });

        var overlays = new Object(),
            markers = new Object(),
            groupedOverlays = new Object();

        var zeldaMap = L.map("map", {
            minZoom: 0,
            maxZoom: 10,
            tileSize: 256,
            attributionControl: false,
            crs: L.CRS.Zelda,
            renderer: L.canvas(),
        });

        var southWest = zeldaMap.unproject([0, imageheight], 8),
            northEast = zeldaMap.unproject([imagewidth, 0], 8),
            bounds = L.latLngBounds(southWest, northEast)

        zeldaMap.setView(L.latLng(-1432, 395), 5);

        var tile_url = 'https://raw.githubusercontent.com/designgears/totk-map-assets/main/tiles/';
        
        var sky = L.tileLayer(tile_url + 'sky_complete/{z}/{x}/{y}.png', { maxNativeZoom: 8, bounds: bounds, name: 'Sky' }),
            surface = L.tileLayer(tile_url + 'ground/{z}/{x}/{y}.png', { maxNativeZoom: 8, bounds: bounds, name: 'Surface' }),
            depths = L.tileLayer(tile_url + 'underground/{z}/{x}/{y}.png', { maxNativeZoom: 8, bounds: bounds, name: 'Depths' }),
            baseLayers = {
                "Sky": sky,
                "Surface": surface,
                "Depths": depths,
            };
        
        var fuseOptions = {
            position: 'topleft',
            maxResultLength: 50,
            threshold: 0.2,
            showInvisibleFeatures: false,
        };
        
        // var searchCtrl = L.control.fuseSearch(fuseOptions).addTo(zeldaMap);
        sky.addTo(zeldaMap);
        new L.Hash(zeldaMap);

        function onEachFeature(feature, layer) {

            feature.layer = layer;

            if (feature.properties.title && feature.properties.category != 'Labels') {
                layer.bindPopup(
                    feature.properties.title+'<br />'+feature.properties.description
                )
            }

            layer.addTo(groupedOverlays[feature.properties.map][feature.properties.category][feature.properties.subcat]);

        }

        function pointToLayer(feature, latlng) {

            if (completedMarkers.indexOf(feature.properties.hash) > -1 ) {
                feature.properties.completed = true;
            }

            addToOverlays(feature.properties.map, feature.properties.category, feature.properties.subcat);

            if (feature.properties.radius) {
                return L.circle(latlng, {
                    radius: feature.properties.radius
                });
            } else if (feature.properties.category == 'Labels') {
                return L.canvasMarker(latlng, markers[feature.properties.category]);
            } else {
                var markerOptions = {
                    color: feature.properties.color
                }
                return new L.canvasMarkerCircle(latlng, markerOptions);
            }
        }

        function addToOverlays(map, category, subcat) {
            if (!(map in groupedOverlays)) {
                groupedOverlays[map] = {};
            }
            if (!(category in groupedOverlays[map])) {
                groupedOverlays[map][category] = {};
            }
            if (!(subcat in groupedOverlays[map][category])) {
                groupedOverlays[map][category][subcat] = new L.LayerGroup();
            }
        }

        var control;
        $.getJSON("../data.json", function(markers) {
            L.geoJSON(markers, {
                pointToLayer: pointToLayer,
                onEachFeature: onEachFeature
            });

            var menu_options = {
                groupCheckboxes: true,
                collapsed: false,
                groupsCollapsable: true,
                groupsExpandedClass: 'bi bi-caret-down-square-fill',
                groupsCollapsedClass: 'bi bi-caret-right-square-fill',
            };

            control = L.control.groupedLayers(baseLayers, groupedOverlays['Sky'], menu_options).addTo(zeldaMap);
            //searchCtrl.indexFeatures(markers, ['title', 'contents']);
        });
        
        zeldaMap.on('baselayerchange', (e) => {
            previousBaseLayer = currentBaseLayer;
            currentBaseLayer = e.name;
            updateLayers();
        })

        var currentBaseLayer = 'Sky';
        var previousBaseLayer;
        function updateLayers() {

            // this entire function needs to be built into leaflet.groupedlayercontrol.js

            if (previousBaseLayer) {
                for (var category in groupedOverlays[previousBaseLayer]) {
                    for (var subcat in groupedOverlays[previousBaseLayer][category]) {
                        for (var marker in groupedOverlays[previousBaseLayer][category][subcat]._layers) {
                            groupedOverlays[previousBaseLayer][category][subcat]._layers[marker].remove();
                        }
                        control.removeLayer(groupedOverlays[previousBaseLayer][category][subcat]);
                    }
                }
            }

            for (var category in groupedOverlays[currentBaseLayer]) {
                for (var subcat in groupedOverlays[currentBaseLayer][category]) {
                    for (var marker in groupedOverlays[currentBaseLayer][category][subcat]._layers) {
                        groupedOverlays[currentBaseLayer][category][subcat]._layers[marker].addTo(groupedOverlays[currentBaseLayer][category][subcat]);
                    }
                    control.addOverlay(groupedOverlays[currentBaseLayer][category][subcat], subcat, category)
                }
            }
        }

    </script>
    <!-- <script type="text/javascript" src="assets/js/enable-drawing.js"></script> -->

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-06ZP4VCJQG"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-06ZP4VCJQG');
    </script>

  </body>
</html>